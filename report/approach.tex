\section{Approach}
In this section, we detail our implementation for injecting faults, methods to predict program outcome along with fault types.

\subsection{Pipeline}
Figure~\ref{fig:pipeline} shows the general pipeline of our proposed system. For any target application, it is first modified to contain at least one call to initialize fault injection. The program is then compiled under architecture X86 or ALPHA which is supported by GemFI. We choose ALPHA as our test architecture as it is lightweight and fully supports the fault injection. Following the compilation, the generated binary should be moved to a disk image which is serving as a virtual disk for GemFI execution. The specific faults are provided by the user through a file at command line. Each line of the input file specifies the attributes of a single fault. This will be discussed in detail in Section \ref{section:FI}. 

GemFI simulator simulates the execution of the target application until a fault is to be activated. When it is time, the GemFI simulator will modify the state of the hardware e.g. flip the bit or set the value to all 0 according to the fault specification. The output of the program may differ based on whether the faults have been masked or not. These outputs will serve as the labels of our training data. The simulator generates statistics of a varying-length capturing microarchitecture event periodically. These raw features will serve as the feature vectors of our training data. Feature extraction will be detailed in Section \ref{section:FE}. 

Our feature extraction and labelling module will extracts standardized features from raw features and label them based on the result of the test program. These standardized features will then feed into Machine Learning component for ML algorithms to learn meaningful features. Details about machine learning analysis will be discussed in Section \ref{section:ML}

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/teaser.png}
\end{center}
   \caption{\footnotesize Motivation to extract meaningful features}
\vspace{-0.5cm}
\label{fig:teaser}
\end{figure}

\begin{figure*}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/pipeline.png}
\end{center}
   \caption{\footnotesize General pipeline of our work. GemFi simulator restores from the checkpoint which saves the warm up stage of the system and takes in test program, input data of the test program and the fault injection script. It then simulates the execution of the program and generates the raw features. Our feature extraction and labeling module will then extract common feature and label each feature vector for binary and multi-class classification. The machine learning algorithms learn models from the features and also output useful features.}
\vspace{-0.3cm}
\label{fig:pipeline}
\end{figure*}



\subsection{Fault Injection}\label{section:FI}
The faults are provided by the user through an input file. Each line of the input file specifies the attributes of a single fault. Faults are characterized by four attributes: Location, Thread, Time and Behavior. 
\begin{itemize}
\item Location: Location specifies which microarchitectural modules the fault would be injected into, e.g. registers, the fetched instructions and PC address
\item Thread: Thread offers the flexibility for the user to selectively inject faults
\item Time: Faults are scheduled to the number of instructions already executed, or to the number of elapsed simulation ticks of the targeted thread
\item Behavior: Behavior specifies which operation the fault will corrupt the module. Flipping bits, XORing or setting all bits to 0,1 are some of the operations supported by GemFI
\end{itemize}

An example below shows the a sample input of faults. 
\begin{lstlisting}	
RegisterInjectedFault Inst:17958 Flip:16 
     Threadid:0 system.cpu1 occ:1 int 1
\end{lstlisting}

This example describes a fault that injects into the $16th$ bit of the register R1 in CPU, when the application fetches $17958th$ instruction after the initiation of fault injection. 

In our work, we focus on four types of faults: \textit{GeneralFetchInjectedFault}, \textit{LoadStoreInjectedFault}, \textit{ExecutionInjectedFault} and \textit{OpCodeInjectedFault}. And we choose the instruction as the criteria for when to inject faults. This makes it easy to know the exact number of instructions executed from the output. We employ flipping bit operation to inject a fault as it is the most common transient fault in real hardware. 



\subsection{Feature Extraction and Labeling}\label{section:FE}
\subsubsection{Feature Extraction}
GemFI generates a \emph{stats} file which contains the statistics for each period capturing microarchitecture events. However, the number and type of features in each period may vary greatly for different types of faults, different execution status and different results. So in order to obtain a fixed length of features of each period, we extract all the common features from the \emph{stats} files. 
\subsubsection{Labeling}
There are three kinds of output from the test. The first kind of output is when the fault is masked by the hardware producing a correct result. This happens a lot as the operation of flipping a bit is very likely to be masked. The second kind of output occurs when the test program encounters a segmentation fault during the execution. The last kind is when the execution of the program exits normally however the output is not correct. Among all the faulty execution of the program, the second kind is the one that commonly observed. We will label the first condition as 0 which leads to the correct output and label the latter two conditions as 1 in binary classification. For multi-class classification labels 1, 2, 3, 4 are used to label different types of faults injected.

\subsection{Checkpoint Restoring}
We also employ checkpoint mechanism to save the simulation time of a test program. For simulating a test program, GemFI first loads the entire linux system in detailed mode and then executes the program. This loading step takes about 5 minutes and usually uses 90\% of the total simulation time. By creating a checkpoint after the system has been loaded, we can directly simulate the test program next time by restoring this checkpoint. This saves us large amount of time in generating training data. 

\input{ml_analysis}
