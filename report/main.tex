%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the template for submission to ISCA 2016
% The cls file is a modified from  'sig-alternate.cls'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{sig-alternate} 
\usepackage{mathptmx} % This is Times font

\newcommand{\ignore}[1]{}
\usepackage{fancyhdr}
\usepackage[normalem]{ulem}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{listings}


%%%%%%%%%%%---SETME-----%%%%%%%%%%%%%
\newcommand{\hpcasubmissionnumber}{NaN}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\fancypagestyle{firstpage}{
  \fancyhf{}
\setlength{\headheight}{50pt}
\renewcommand{\headrulewidth}{0pt}
  \fancyhead[C]{} 
  \pagenumbering{arabic}
}  

%%%%%%%%%%%---SETME-----%%%%%%%%%%%%%
\title{Extract Useful Features for Detecting Transient Faults} 
\author{Zhiqiang Sui, Zhefan Ye, Karthik Desingh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\thispagestyle{firstpage}
\pagestyle{plain}

\begin{abstract}

\end{abstract}

\section{Introduction}
In this report, we present a pipeline that can inject faults into programs and analyze how injected fault can alter program outcomes. To detect transient fault has been a research topic in robust system design for years. We utilize gemFI to study how faults are going to affect programs. Our contribution is two-fold: we implemented a fault inject pipeline, and provide analysis on how to predict fault and program outcome based on a machine learning approach. Figure~\ref{fig:teaser} shows the overview of our approach.

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/teaser.png}
\end{center}
   \caption{Overview}
\label{fig:teaser}
\end{figure}

\section{Related Work}

\section{Approach}
In this section, we present our implementation for injecting faults, as well as analysis for predicting program outcome and fault types.

\subsection{Pipeline}
Figure~\ref{fig:pipeline} shows the pipeline.
\begin{figure*}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/pipeline.png}
\end{center}
   \caption{}
\label{fig:pipeline}
\end{figure*}

\subsection{Fault Injection}
GemFI \cite{parasyris2014gemfi} supports two kind of architectures: ALPHA and X86. In our project, we choose ALPHA as our test architecture. In order to inject faults into the test program, it needs to be modified to initialize the fault injection. The target application is cross-compiled by the alpha gnu toolchain and linked with FI libraries. Afterwards, the generated binary should be moved to the disk image serving as the virtual disk of GemFI. The specific faults are provided by the user in a file at command line. Each line of the input file specifies the attributes of a single fault. Faults are characterized by four attributes: Location, Thread, Time and Behavior. 

An example below shows the a sample input of faults. 
\begin{lstlisting}[language=bash]
RegisterInjectedFault Inst:2457 Flip:21 Threadid:0 system.cpu1 occ:1 int 1
\end{lstlisting}

This example describes a fault that injects into the $21st$ bit of the register R1 of the CPU, when the application fetches $2457th$ instruction after the initiation of fault injection. For our current tests, we just generate faults by randomly sampling from the number of instructions of the test program, the components of ALPHA and the operations needed. However, this method couldn't cause the program to generate false results some time as different programs make use of different components at different time. So we will explore the running characteristics of each test program and generate faults from a finer and smaller space. 

\subsection{Test Bench}
We use MiBench \cite{guthaus2001mibench} as our test bench for injecting faults and evaluating our system. MiBench is a representative embedded benchmark. We choose MiBench because of its compact program size and versatile program characteristics. We choose qsort as our test program.

\subsection{Feature Extraction}
We extract all the common features from the \emph{stats} files generated by GemFI. Since some fault injected program will generate fewer features than non-fault injected program, we only choose those the features appeared in both programs.
\begin{figure*}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/feat_dist.png}
\end{center}
   \caption{}
\label{fig:feat-dist}
\end{figure*}

\subsection{Machine Analysis}
We use the random forest algorithm to predict program outcome and fault type. A random forest is essentially an ensemble of single decision trees, as illustrated in ~\ref{fig:rf} \cite{breiman2001random}. It captures different models of the data, with each decision tree representing a model, and allows us to analyze the importance of different features. 

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/rf.png}
\end{center}
   \caption{}
\label{fig:rf}
\end{figure}

\subsubsection{Training and Testing}
We randomly select $60\%$ of instances for training and $40\%$ of instances for testing. Our dataset consists of $98,000$ data instance.

\section{Experiment}

\subsection{Metrics}
we use Precision-Recall (PR) curve and $F_1$ score as our evaluation criteria. More precisely, we have
\begin{equation}
F_{1} = 2\cdot\frac{precision \cdot recall}{precision + recall},
\end{equation}
where $precision = \frac{tp}{tp+fp}$, $recall = \frac{tp}{tp+fn}$, $tp$ is the number true positive samples, $fp$ is number of false positive samples, and $fn$ is the number of false negative samples. For multi-class classification, we use confusion matrix to describe the performance of our classifier.

\subsection{Experiment Setups}
Here are our four experiment setups: 1) same input data with all features, 2) same input data with handpicked subsets of features, 3) different input data with all meaningful features, and 4) different input data with handpicked subsets of features.

\section{Result}
\subsection{Same Input All Features}
(same input all features SIAF)

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/siaf.png}
\end{center}
   \caption{}
\label{fig:siaf}
\end{figure}

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/siaf_multi.png}
\end{center}
   \caption{}
\label{fig:siaf-multi}
\end{figure}

The random forest algorithm output the importance score of each feature based on its discriminative power. The importance feature ranking is depicted in Figure~\ref{fig:feat-same}.
\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/feat_same.png}
\end{center}
   \caption{}
\label{fig:feat-same}
\end{figure}

\subsection{Same Input Different Features}
(same input handpicked features SIHF)

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/sidf.png}
\end{center}
   \caption{}
\label{fig:sidf}
\end{figure}

\subsection{Different Input All Features}
(different input all features DIAF)

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/diaf_multi.png}
\end{center}
   \caption{}
\label{fig:diaf-multi}
\end{figure}

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/disf.png}
\end{center}
   \caption{}
\label{fig:disf}
\end{figure}

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/feat_diff.png}
\end{center}
   \caption{}
\label{fig:feat-diff}
\end{figure}

\subsection{Different Input Different Features}
Different Input Handpicked Features DIHF

\begin{figure}[t]
\begin{center}
   \includegraphics[width=0.95\linewidth]{./figures/didf.png}
\end{center}
   \caption{}
\label{fig:didf}
\end{figure}

\subsection{Cross Application Predication}


\section{Discussion and Conclusion}
In the same input scenario, a few features alone can determine the results in same input condition. For same input the most important features are mainly describing the execution length. For d different input scenario: the features such as, “type of functional units issued”, “fetch instructions” and “cache read and write”, play important role in the prediction. Overall features based on “L2 cache” events perform higher than other set of hand-picked features. However, when all the features are used, the performance of the random forest algorithm is high. We extract meaningful fault signatures from the architectural events that can be used to predict transient fault occurrence.


%%%%%%% -- PAPER CONTENT ENDS -- %%%%%%%%

%%%%%%%%% -- BIB STYLE AND FILE -- %%%%%%%%
\bibliographystyle{ieeetr}
\bibliography{ref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
